C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE FILTER
OBJECT MODULE PLACED IN .\Objects\Filter.obj
COMPILER INVOKED BY: D:\Program Files\keil51\C51\BIN\C51.EXE Code\Filter.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Code) DEBUG
                    - OBJECTEXTEND PRINT(.\Listings\Filter.lst) TABS(2) OBJECT(.\Objects\Filter.obj)

line level    source

   1          #include "reg52.h"
   2          #include "headfile.h"
   3          
   4          uchar data_filtered;
   5          xdata float ratio_buffer[3] = {0.6,0.3,0.1};
   6          uchar filter_type = 11;
   7          
   8          uchar SpeedLimit_Filter(uchar data_raw, uchar limit_threshold)//限速滤波
   9          {
  10   1        static uchar data_buff[3];
  11   1        static uchar income_times;
  12   1        uchar data_temp;
  13   1        
  14   1        if(income_times<3)
  15   1        {
  16   2          data_buff[income_times] = data_raw;
  17   2          income_times = income_times + 1;
  18   2        }
  19   1        else
  20   1        {
  21   2          data_buff[0] = data_buff[1];
  22   2          data_buff[1] = data_buff[2];
  23   2          data_buff[2] = data_raw;
  24   2        }
  25   1        
  26   1        if(income_times<3)
  27   1        {
  28   2          data_temp = data_buff[2];
  29   2        }
  30   1        else
  31   1        {
  32   2          if(abs(data_buff[1] - data_buff[0]) <= limit_threshold)
  33   2          {
  34   3            data_temp = data_buff[1]; 
  35   3          }
  36   2          else
  37   2          {
  38   3            if(abs(data_buff[1] - data_buff[0]) > limit_threshold)
  39   3            {
  40   4              data_temp = (data_buff[2] + data_buff[1])/2;
  41   4            }
  42   3            else
  43   3            {
  44   4              data_temp = data_buff[2]; 
  45   4            }
  46   3          }
  47   2        }
  48   1        return data_temp;
  49   1      }
  50          
  51          uchar Limiting_Filter(uchar data_raw, uchar limit_threshold)//限幅滤波
  52          {
  53   1        static uchar data_buff[2];
  54   1        static uchar income_times;
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 2   

  55   1        uchar data_temp;
  56   1        
  57   1        if(income_times<2)
  58   1        {
  59   2          data_buff[income_times] = data_raw;
  60   2          income_times = income_times + 1;
  61   2        }
  62   1        else
  63   1        {
  64   2          data_buff[0] = data_buff[1];
  65   2          data_buff[1] = data_raw;
  66   2        }
  67   1        
  68   1        if(abs(data_buff[1] - data_buff[0]) <= limit_threshold)
  69   1        {
  70   2          data_temp = data_buff[1];
  71   2        }
  72   1        else
  73   1        {
  74   2          data_buff[1] = data_buff[0];
  75   2          data_temp = data_buff[1];
  76   2        }
  77   1        return data_temp;
  78   1      }
  79          
  80          uchar Median_Filter(uchar data_raw, uchar buffer_size)//中位数滤波
  81          {
  82   1        static uchar data_buff[5];
  83   1        static uchar income_times;
  84   1        uchar data_temp;
  85   1        uchar i;
  86   1        
  87   1        if(income_times<buffer_size)
  88   1        {
  89   2          data_buff[income_times] = data_raw;
  90   2          income_times = income_times + 1;
  91   2        }
  92   1        else
  93   1        {
  94   2          for(i=0;i<income_times-1;income_times++)
  95   2          {
  96   3            data_buff[i] = data_buff[i+1];
  97   3          }
  98   2          data_buff[income_times-1] = data_raw;
  99   2        }
 100   1        
 101   1        if(income_times<buffer_size)
 102   1        {
 103   2          data_temp = data_buff[income_times];
 104   2        }
 105   1        else
 106   1        {
 107   2          data_temp = Mid_Sort(data_buff,buffer_size);
 108   2        }
 109   1        
 110   1        return data_temp;
 111   1      }
 112          
 113          uchar Average_Filter(uchar data_raw, uchar buffer_size)//算数平均滤波
 114          {
 115   1        static uchar data_buff[5];
 116   1        static uchar income_times;
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 3   

 117   1        static uchar load_times;
 118   1        static uchar data_temp;
 119   1        uchar i;
 120   1        uchar sum = 0;
 121   1        
 122   1        if(income_times<buffer_size)
 123   1        {
 124   2          data_buff[income_times] = data_raw;
 125   2          income_times = income_times + 1;
 126   2        }
 127   1        else
 128   1        {
 129   2          for(i=0;i<income_times-1;income_times++)
 130   2          {
 131   3            data_buff[i] = data_buff[i+1];
 132   3          }
 133   2          data_buff[income_times-1] = data_raw;
 134   2        }
 135   1        
 136   1        if(income_times<buffer_size)
 137   1        {
 138   2          data_temp = data_buff[income_times];
 139   2        }
 140   1        else
 141   1        {
 142   2          if(++load_times==buffer_size)
 143   2          {
 144   3            buffer_size = 0;
 145   3            for(i=0;i<buffer_size;i++)
 146   3            {
 147   4              sum = sum + data_buff[i];
 148   4            }
 149   3            data_temp = sum/buffer_size;
 150   3          }
 151   2        }
 152   1        
 153   1        return data_temp;
 154   1      }
 155          
 156          
 157          uchar MovingAverage_Filter(uchar data_raw, uchar buffer_size)//滑动平均滤波
 158          {
 159   1        static uchar data_buff[5];
 160   1        static uchar income_times;
 161   1        uchar data_temp;
 162   1        uchar i;
 163   1        uchar sum = 0;
 164   1        
 165   1        if(income_times<buffer_size)
 166   1        {
 167   2          data_buff[income_times] = data_raw;
 168   2          income_times = income_times + 1;
 169   2        }
 170   1        else
 171   1        {
 172   2          for(i=0;i<income_times-1;income_times++)
 173   2          {
 174   3            data_buff[i] = data_buff[i+1];
 175   3          }
 176   2          data_buff[income_times-1] = data_raw;
 177   2        }
 178   1        
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 4   

 179   1        if(income_times<buffer_size)
 180   1        {
 181   2          data_temp = data_buff[income_times];
 182   2        }
 183   1        else
 184   1        {
 185   2            for(i=0;i<buffer_size;i++)
 186   2            {
 187   3              sum = sum + data_buff[i];
 188   3            }
 189   2            data_temp = sum/buffer_size;
 190   2      
 191   2        }
 192   1        
 193   1        return data_temp;
 194   1      }
 195          
 196          uchar MidAvg_Filter(uchar data_raw, uchar buffer_size)//中位值平均滤波
 197          {
 198   1        static uchar data_buff[5];
 199   1        static uchar income_times;
 200   1        uchar data_temp;
 201   1        uchar i;
 202   1        uchar sum = 0;
 203   1        uchar temp_buff[5];
 204   1        
 205   1        if(income_times<buffer_size)
 206   1        {
 207   2          data_buff[income_times] = data_raw;
 208   2          income_times = income_times + 1;
 209   2        }
 210   1        else
 211   1        {
 212   2          for(i=0;i<income_times-1;income_times++)
 213   2          {
 214   3            data_buff[i] = data_buff[i+1];
 215   3          }
 216   2          data_buff[income_times-1] = data_raw;
 217   2        }
 218   1        
 219   1        if(income_times<buffer_size)
 220   1        {
 221   2          data_temp = data_buff[income_times];
 222   2        }
 223   1        else
 224   1        {
 225   2            for(i=0;i<buffer_size;i++)
 226   2            {
 227   3              temp_buff[i] = data_buff[i];
 228   3            }
 229   2            Bubble_Sort(temp_buff,buffer_size);
 230   2            for(i=1;i<buffer_size-1;i++)
 231   2            {
 232   3              sum = sum + temp_buff[i];
 233   3            }
 234   2            data_temp = sum/(buffer_size-2);
 235   2        }
 236   1        
 237   1        return data_temp;
 238   1      }
 239          
 240          uchar LimitAvg_Filter(uchar data_raw, uchar buffer_size, uchar limit_threshold)//限幅平均滤波
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 5   

 241          {
 242   1        static uchar data_buff[5];
 243   1        static uchar income_times;
 244   1        uchar data_temp;
 245   1        uchar i;
 246   1        uchar sum = 0;
 247   1        uchar temp_buff[5];
 248   1        
 249   1        if(income_times<buffer_size)
 250   1        {
 251   2          data_buff[income_times] = data_raw;
 252   2          income_times = income_times + 1;
 253   2        }
 254   1        else
 255   1        {
 256   2          for(i=0;i<income_times-1;income_times++)
 257   2          {
 258   3            data_buff[i] = data_buff[i+1];
 259   3          }
 260   2          data_buff[income_times-1] = data_raw;
 261   2        }
 262   1        
 263   1        if(income_times<buffer_size)
 264   1        {
 265   2          data_temp = data_buff[income_times];
 266   2        }
 267   1        else
 268   1        {
 269   2          temp_buff[0] = data_buff[0];
 270   2          for(i=1;i<buffer_size;i++)
 271   2          {
 272   3            if(abs(data_buff[i]-data_buff[i-1])<=limit_threshold)
 273   3            {
 274   4              temp_buff[i] = data_buff[i];
 275   4            }
 276   3            else
 277   3            {
 278   4              temp_buff[i] = data_buff[i-1];
 279   4            }
 280   3            sum = sum + temp_buff[i];
 281   3          }
 282   2          sum = sum + temp_buff[0];
 283   2          data_temp = sum/buffer_size;
 284   2        }
 285   1        
 286   1        return data_temp;
 287   1      }
 288          
 289          uchar FirstOrderLag_Filter(uchar data_raw, float ratio)//一阶滞后滤波
 290          {
 291   1        static uchar data_buff[3];
 292   1        static uchar income_times;
 293   1        uchar data_temp;
 294   1        
 295   1        if(income_times<2)
 296   1        {
 297   2          data_buff[income_times] = data_raw;
 298   2          income_times = income_times + 1;
 299   2        }
 300   1        else
 301   1        {
 302   2          data_buff[0] = data_buff[1];
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 6   

 303   2          data_buff[1] = data_raw;
 304   2        }
 305   1        
 306   1        if(income_times<2)
 307   1        {
 308   2          data_temp = data_buff[income_times];
 309   2        }
 310   1        else
 311   1        {
 312   2          data_temp = ratio*data_buff[1] + (1-ratio)*data_buff[0];
 313   2        }
 314   1        
 315   1        return data_temp;
 316   1      }
 317          
 318          uchar WeightedMovAvg_Filter(uchar data_raw, uchar buffer_size, float ratio_buffer[])//加权平均滤波
 319          {
 320   1        static uchar data_buff[5];
 321   1        static uchar income_times;
 322   1        float data_temp;
 323   1        uchar i;
 324   1        
 325   1        if(income_times<buffer_size)
 326   1        {
 327   2          data_buff[income_times] = data_raw;
 328   2          income_times = income_times + 1;
 329   2        }
 330   1        else
 331   1        {
 332   2          for(i=0;i<income_times-1;income_times++)
 333   2          {
 334   3            data_buff[i] = data_buff[i+1];
 335   3          }
 336   2          data_buff[income_times-1] = data_raw;
 337   2        }
 338   1        
 339   1        if(income_times<2)
 340   1        {
 341   2          data_temp = data_buff[income_times];
 342   2        }
 343   1        else
 344   1        {
 345   2          for(i=0;i<buffer_size;i++)
 346   2          {
 347   3            data_temp = data_temp + ratio_buffer[i] * data_buff[i];
 348   3          }
 349   2        }
 350   1        
 351   1        return (uchar)data_temp;
 352   1      }
 353          
 354          uchar Glitch_Filter(uchar data_raw, uchar buffer_size)//消抖滤波
 355          {
 356   1        static uchar data_buff;
 357   1        static uchar income_times;
 358   1        static uchar diff_times;
 359   1        uchar data_temp;
 360   1        
 361   1        if(income_times<1)
 362   1        {
 363   2          data_buff = data_raw;
 364   2        }
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 7   

 365   1        else
 366   1        {
 367   2          if(data_raw!=data_buff)
 368   2          {
 369   3            if(++diff_times>buffer_size)
 370   3            {
 371   4              diff_times = 0;
 372   4              data_buff = data_raw;
 373   4            }
 374   3          }
 375   2        }
 376   1        data_temp = data_buff;
 377   1        
 378   1        return data_temp;
 379   1      }
 380          
 381          uchar LimitGlitch_Filter(uchar data_raw, uchar buffer_size, uchar limit_threshold)//限幅消抖滤波
 382          {
 383   1        static uchar data_buff;
 384   1        static uchar income_times;
 385   1        static uchar data_last;
 386   1        static uchar diff_times;
 387   1        uchar data_temp;
 388   1        uchar data_now;
 389   1        
 390   1        if(income_times<buffer_size)
 391   1        {
 392   2          data_now = data_raw;
 393   2          data_buff = data_now;
 394   2        }
 395   1        else
 396   1        {
 397   2          if(abs(data_now - data_last)>limit_threshold)
 398   2          {
 399   3            data_now = data_last;
 400   3            if(data_now!=data_buff)
 401   3            {
 402   4              if(++diff_times>buffer_size)
 403   4              {
 404   5                diff_times = 0;
 405   5                data_buff = data_raw;
 406   5              }
 407   4            }
 408   3          }
 409   2        }
 410   1        
 411   1        data_temp = data_buff;
 412   1        data_last = data_temp;
 413   1        
 414   1        return data_temp;
 415   1      }
 416          
 417          void Filter_Choose(uchar choice)
 418          {
 419   1        switch(choice)
 420   1        {
 421   2          case 0: data_filtered = SpeedLimit_Filter(adc_value, 5);break;
 422   2          case 1: data_filtered = Limiting_Filter(adc_value, 10);break;
 423   2          case 2: data_filtered = Median_Filter(adc_value, 3);break;
 424   2          case 3: data_filtered = Average_Filter(adc_value, 5);break;
 425   2          case 4: data_filtered = MovingAverage_Filter(adc_value, 5);break;
 426   2          case 5: data_filtered = MidAvg_Filter(adc_value, 5);break;
C51 COMPILER V9.56.0.0   FILTER                                                            12/18/2022 18:21:04 PAGE 8   

 427   2          case 6: data_filtered = LimitAvg_Filter(adc_value, 3, 5);break;
 428   2          case 7: data_filtered = FirstOrderLag_Filter(adc_value, 0.7);break;
 429   2          case 8: data_filtered = WeightedMovAvg_Filter(adc_value, 3, ratio_buffer);break;
 430   2          case 9: data_filtered = Glitch_Filter(adc_value, 3);break;
 431   2          case 10: data_filtered = LimitGlitch_Filter(adc_value, 3, 5);break;
 432   2          case 11: data_filtered = adc_value;break;
 433   2          default: break;
 434   2        }
 435   1      }
 436          
 437          
 438          
 439          
 440          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1393    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58      40
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
